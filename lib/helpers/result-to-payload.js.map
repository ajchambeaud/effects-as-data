{"version":3,"sources":["../../src/helpers/result-to-payload.js"],"names":[],"mappings":";;;;;;eAAwC,OAAO,CAAC,OAAO,CAAC;;IAAhD,OAAO,YAAP,OAAO;IAAE,MAAM,YAAN,MAAM;IAAE,KAAK,YAAL,KAAK;IAAE,GAAG,YAAH,GAAG;;gBACL,OAAO,CAAC,YAAY,CAAC;;IAA3C,KAAK,aAAL,KAAK;IAAE,UAAU,aAAV,UAAU;;AAEzB,SAAS,eAAe,CAAE,IAAI,EAAE;AAC9B,MAAI,KAAK,GAAG,YAAY,CAAC,IAAI,CAAC,CAAA;AAC9B,SAAO,gBAAsC;QAA3B,OAAO,QAAP,OAAO;QAAE,MAAM,QAAN,MAAM;QAAE,OAAO,QAAP,OAAO;;AACxC,QAAI,YAAY,GAAG,GAAG,CAAC,iBAAkB;;;UAAhB,GAAG;UAAE,KAAK;;AACjC,UAAI,MAAM,CAAC,GAAG,CAAC,EAAE;AACf,eAAO,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAA;OAC1B;KACF,EAAE,KAAK,CAAC,CAAA;;AAET,QAAI,UAAU,GAAG,MAAM,CAAC,UAAC,CAAC,SAAmB;;;UAAhB,GAAG;UAAE,KAAK;;AACrC,UAAI,OAAO,CAAC,GAAG,CAAC,EAAE;AAChB,eAAO,KAAK,CAAC,CAAC,sBACX,KAAK,EAAG,OAAO,CAAC,GAAG,CAAC,EACrB,CAAA;OACH,MAAM;AACL,eAAO,CAAC,CAAA;OACT;KACF,EAAE,OAAO,EAAE,KAAK,CAAC,CAAA;;AAElB,WAAO,YAAY,CAChB,MAAM,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAChC,MAAM,CAAC,UAAA,CAAC;aAAI,CAAC;KAAA,CAAC,CAAA;GAClB,CAAA;CACF;;AAED,SAAS,YAAY,CAAE,CAAC,EAAE;AACxB,MAAI,IAAI,YAAA,CAAA;AACR,MAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;AACpB,QAAI,GAAG,MAAM,CAAC,UAAC,CAAC,EAAE,CAAC,EAAK;AACtB,OAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAA;AACR,aAAO,CAAC,CAAA;KACT,EAAE,EAAE,EAAE,CAAC,CAAC,CAAA;GACV,MAAM,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;AAChC,QAAI,uBAAK,CAAC,EAAG,CAAC,CAAC,CAAA;GAChB,MAAM;AACL,QAAI,GAAG,CAAC,CAAA;GACT;;AAED,SAAO,OAAO,CAAC,IAAI,CAAC,CAAA;CACrB;;AAED,MAAM,CAAC,OAAO,GAAG;AACf,iBAAe,EAAf,eAAe;CAChB,CAAA","file":"result-to-payload.js","sourcesContent":["const { toPairs, reduce, merge, map } = require('ramda')\nconst { panic, setPayload } = require('../actions')\n\nfunction resultToPayload (keys) {\n  let pairs = normalizeMap(keys)\n  return function ({context, errors, payload}) {\n    let errorActions = map(([key, toKey]) => {\n      if (errors[key]) {\n        return panic(errors[key])\n      }\n    }, pairs)\n\n    let newPayload = reduce((p, [key, toKey]) => {\n      if (context[key]) {\n        return merge(p, {\n          [toKey]: context[key]\n        })\n      } else {\n        return p\n      }\n    }, payload, pairs)\n\n    return errorActions\n      .concat([setPayload(newPayload)])\n      .filter(v => v)\n  }\n}\n\nfunction normalizeMap (m) {\n  let keys\n  if (Array.isArray(m)) {\n    keys = reduce((p, c) => {\n      p[c] = c\n      return p\n    }, {}, m)\n  } else if (typeof m === 'string') {\n    keys = {[m]: m}\n  } else {\n    keys = m\n  }\n\n  return toPairs(keys)\n}\n\nmodule.exports = {\n  resultToPayload\n}\n"]}